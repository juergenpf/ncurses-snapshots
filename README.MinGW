-------------------------------------------------------------------------------
-- Copyright 2020 Thomas E. Dickey                                           --
-- Copyright 2008-2011,2012 Free Software Foundation, Inc.                   --
--                                                                           --
-- Permission is hereby granted, free of charge, to any person obtaining a   --
-- copy of this software and associated documentation files (the             --
-- "Software"), to deal in the Software without restriction, including       --
-- without limitation the rights to use, copy, modify, merge, publish,       --
-- distribute, distribute with modifications, sublicense, and/or sell copies --
-- of the Software, and to permit persons to whom the Software is furnished  --
-- to do so, subject to the following conditions:                            --
--                                                                           --
-- The above copyright notice and this permission notice shall be included   --
-- in all copies or substantial portions of the Software.                    --
--                                                                           --
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS   --
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                --
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN --
-- NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,       --
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR     --
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE --
-- USE OR OTHER DEALINGS IN THE SOFTWARE.                                    --
--                                                                           --
-- Except as contained in this notice, the name(s) of the above copyright    --
-- holders shall not be used in advertising or otherwise to promote the      --
-- sale, use or other dealings in this Software without prior written        --
-- authorization.                                                            --
-------------------------------------------------------------------------------
-- $Id: README.MinGW,v 1.14 2020/09/06 22:22:44 tom Exp $
-- Author: Juergen Pfeifer
-------------------------------------------------------------------------------

This is work in progress, but it is in a state where one can see it
works at least on the Windows Console.

Before we dive into the details how to build and test ncurses for Windows, let
me set expectations. Although Windows now for a while has a console subsystem 
that accepts ANSI control sequences, there is one fundamental difference to most
UNIX-like operating systems e.g. Linux. In Linux, when the console is in
UTF-8 mode, the console handles the UTF-8 encoding for you if you send a
non-ASCII character. This is not true on Windows. If the console is in UTF-8
mode, it expects the application to send UTF-8 encoded character sequences. 

This fundamental difference in console behaviour has consequences for the 
terminfo low level interface usage. As you know, terminfo is used to query
the terminal capability database and to translate abstract requests into 
concrete code to be send to the terminal, like doing cursor positioning,
enabling/disabling character attributes like boldness etc. or sending
sequences to clear the screen, insert or delete lines etc. - you get it.
All this works with this Windows port on all Windows versions since
10.0 Build 17763. The terminfo paradigm assumes, that everything else
to be written to the console is done by standard library I/O routines.
And this makes the use of terminfo not really portable to Windows, 
because as said above, in Windows you have to take care of UTF-8 encoding
yourself. There is no way to fix that easily.

Nevertheless is terminfo usable on Windows, it's just that it only works like
on UNIX as long as you don't output something that requires multibyte UTF-8
encoding. And of course all that is if you use --enable-widec when configuring
the build. If you use --disable-widec and build a legacy non-unicode version of
the library, everything should be compatible.

In the layer above terminfo, the ncurses, panel, menu and form library we
have full control over the output and can handle this issue, so these
libraries are fully portable, even for Windows Versions before 10.0.17763!

But now let's talk about building and testing the libraries.

I recommend using one of the Linux distributions that supports the MinGW
cross-build packages. Because we develop for Windows, it's nice to be able
to develop on Windows using WSL2 to host a Linux subsystem.
The author is using Ubuntu under WSL2, not because it's a preference but it
is the most common WSL2 distribution, well supported by the partners Canonical
and Microsoft and most tips and tricks you'll find are using Ubuntu as an example.

In Ubuntu just install the mingw-w64 package:

$ sudo apt update
$ sudo apt install mingw-w64 

It will install the whole suite of compilers, tools, and libraries you need to 
cross-build for the Windows MSVCRT environment, the classical - although 
outdated - C runtime on Windows.

You should enable Interop, so your WSL Ubuntu can call Windows programs. 
Find the details how to configure WSL2 here:

	https://learn.microsoft.com/en-us/windows/wsl/wsl-config

Do not install vscode in Ubuntu, but on Windows. vscode has a special extension 
built-in for WSL2 support, so with your Windows-based vscode you can develop in 
WSL2 Linux. You can find the details about developing for WSL2 with vscode here:

	https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-vscode

Even with interop, I do not recommend running test programs from within a WSL2
shell. The terminal characteristics are different from Windows and you should
test directly on Windows. 

Fortunately, WSL2 supports to navigate from Windows into a WSL2 filesystem.
So in CMD.EXE or Powershell, just do a "pushd \\wsl$\Ubuntu" (assuming Ubuntu
is your WSL2 distribution name) and you are on the root of your Linux subsystem
and can navigate to your test directory.

The "Windows Terminal" is an ideal environment to run and test console programs
on the Windows commandline - with one caveat: don't mix Unicode tests with tests
for 8-bit codepages in the same Windows Terminal session. Your sessions should be
either pure Unicode in all tabs, or pure 8-bit.

If you not yet have Windows Terminal installed, you can get it from the store:

	https://apps.microsoft.com/detail/9n0dx20hk701

In order to allow ncurses programs on Windows to ensure the correct locale and
codepage, ncurses supports two environment variables

	- NC_WINCP      can be set to the desired codepage
	- NC_WIN_CTYPE  can be set to a locale that will be used for LC_CTYPE

Example for legacy 8-bit: 
	NC_WINNCP="1252"
	NC_WIN_CTYPE="German_Germany.1252"

Example for Unicode: 
	NC_WINNCP="65001"
	NC_WIN_CTYPE="German_Germany.UTF-8"

Of course you should set the country to your preference.

This would allow running 8-bit ncurses programs using Latin-1 codepage with a 
German  locale.

Using cross-build is much faster than the rather slow MSYS2 environment, but comes
with one potential drawback: all major Linux distros only support the MinGW target
which is based on the old MSVCRT runtime. This is OK, as ncurses currently only
targets this one. But MSYS2 also supports the newer UCRT C-runtime, which is now
used by all modern Windows systems and apps. MSYS2 has two flavors for that
runtime, one named UCRT64 using the gcc compiler, and one called CLANG64 using 
the clang compiler.

So if you want to build ncurses against these targets, at the moment you have to 
use MSYS2. See below how to get it.

To build a decent but still small footprint ncurses that provides
hooks for interop, I recommend using these options:

	--without-libtool
	--disable-home-terminfo
	--enable-database
	--disable-termcap
	--enable-sp-funcs
	--enable-term-driver
	--enable-named-pipes
	--enable-interop

The following example demonstrates the configuration command line which I am using 
at the moment, assuming you are in your ncurses source directory. I assume you have 
the ncurses sources in the directory ${HOME}/src/ncurses

If that's not the case, do this

$ cd $HOME
$ [ -d $HOME/src ] || mkdir -p $HOME/src
$ cd src
$ git clone https://github.com/thomasdickey/ncurses-snapshots.git ncurses

Now that you have that directory, you can do this

$ NCURSES_SRC=$HOME/src/ncurses 
$ cd $NCURSES_SRC
$ mkdir build
$ mkdir -p inst/mingw64
$ pushd build
$ ../configure \
	--srcdir=.. \
	--prefix=/mingw64 \
	--with-default-terminfo-dir=/mingw64/share/terminfo \
	--host=x86_64-w64-mingw32 \
	--build=x86_64-pc-linux-gnu \
	--without-cxx \
	--without-ada \
	--enable-warnings \
	--enable-assertions \
	--enable-ext-funcs \
	--disable-home-terminfo \
	--disable-echo \
	--disable-getcap \
	--disable-hard-tabs \
	--disable-leaks \
	--disable-macros \
	--disable-overwrite \
	--disable-termcap \
	--enable-opaque-curses \
	--enable-opaque-form \
	--enable-opaque-menu \
	--enable-opaque-panel \
	--enable-pc-files \
	--without-shared \
	--without-manpages \
	--without-libtool \
	--enable-term-driver \
	--enable-named-pipes \
	--without-pkg-config \
	--with-fallbacks=ms-terminal \
	--disable-reentrant \
	--without-pthread \
	--enable-widec \
	--enable-sp-funcs \
	--enable-interop \
	--with-debug \
	--with-progs \
	--with-tests \
	--with-develop \
	--with-trace \
	--enable-database \
	--enable-db-install
$ make -j$(nproc)

If the build was successful, you can install into the test environment

$ make install DESTDIR=$(readlink -f "../inst")
$ popd

Of course you can replace --enable-widec with --disable-widec if you want a
traditional 8-bit only build.

If nothing failed, you have in ./build/test all the test programs you may
examine. So, how do you get to them?

I suggest this for your comfort (assuming you develop on Windows with WSL2):

In the ncurses source directory in the misc folder you'll find the file

	MinGW-WSL2-Profile.ps1

Include this file into your Powershell Profile. Just open Powershell in Windows
Terminal and type

$ notepad $PROFILE

Insert the content of above mentioned file and modify it according to your setup
(ncurses source location and WSL Distribution you use)

Now launch Windows Terminal with a Powershell tab and type this

	PS> nct

You're pushed into the test directory of your build, if it exists at all. You 
can run tests and afterwards just do a popd. Please note, that if you've build 
a non-widec version, this will spawn a new Terminal session that will be setup 
for non-Unicode codepage and locale and use the CMD.EXE command processor.

When it come to development, I suggest vscode. I've described above how to set it
up. Then just do this:

$ cd $HOME/ncurses && code .

This will launch the Windows install of vscode (so no remote graphics involved)
which has a special extension to do development in WSL2.

And what about debugging? Having debugging of Windows apps built in WSL2 in
vscode is a complex setup, involving Wine and other tools. This is simply beyond
the scope of a README. This is also true if you don't use WSL2 but are on a
native Intel Linux box. You can run tests and do debugging, but you have to set up
and configure Wine properly.

But there is a pleasant - IMHO good enough - alternative in the WSL2 scenario. 
Install MSYS2 (see below) and in MSYS2 do

$ pacman -S mingw-w64-x86_64-gdb

to get the MinGW gdb debugger. But how do you access your build and test environment 
from within MSYS2? Here is the recipe:

1. Make sure there is a /home/username in MSYS2, where username should be the
   username you have in your WSL2 distro. If you haven't done special configurations, WSL2
   distros as well as MSYS2 use your Windows username. If that directory doesn't
   exist, simply create it.

2. I now assume, that your MSYS2 username is the same as your WSL2 username, so you
   can use "id -un" to get it. Do this

   $ mkdir -p "/home/$(id -un)/src"

3. Change directory to /home/$(id -un)/src 
   If $HOME is set properly you may use $HOME instead of $(id -un)
   If you already have an ncurses directory there, rename or move it

4. Now comes the trick. Do this

   $ ln -s "//wsl$/Ubuntu/home/$(id -un)/src/ncurses" .

   Because MSYS2 sits on top of the Windows filesystem, it understands its remote
   directory name conventions and can provide access to the WSL2 filesystem.
   Replace the name Ubuntu with the name of your distribution if you use another one.

5. Now, if gdb looks for the sourcefiles, it will find them because you have mirrored
   the filesystem-tree in MSYS2.

6. Now open a Windows Terminal session with a Powershell Tab and do

   PS> nct

   which will push you into the test directory of your build.

   Now you can do this:

      a) If you test a widec build (Unicode), you stay in your current Powershell
         and type this

   	PS> ncdbg xxx.exe

     b) If you test a non-widec legacy build, a separate terminal was launched
        with 8-bit settings and CMD.EXE as command processor. Type this

	> %NCDBG% xxx.exe

   to debug xxx.exe. Replace xxx with the name of the program you want to debug.

This workaround still requires MSYS2, but only for debugging. The build and coding is
done in WSL2, which is much more responsive than MSYS2.

Of course, if you don't use WSL2 but a native Linux Box, you can't use this workaround
and have to use the Wine based approach.

You can get MSYS2 from

	https://www.msys2.org/

On that site you'll also find a package index if you want to install more than just the
core shell environment and the MinGW gdb debugger required by the above-described 
workaround for debugging when doing a cross-build under WSL2 Linux.

To build ncurses for native Windows with support for the new Windows 10 Virtual
Terminal and PseudoConsole support, you should install at least version 8.0 of
the mingw-w64-x86_64-headers package as it appears to have support for the
required Windows SDK level.  Please note that some of the Linux distributions
are a bit behind with respect to the required MinGW header versions and you may
not be able to properly build the libraries for current Windows 10 using these
toolchains.  Although it is a bit slow, MSYS2 on Windows 10 64-Bit is the
authoritative build environment for the MinGW version of ncurses.

Using MinGW is a pragmatic decision; it is the easiest way to port this
heavily UNIX-based codebase to native Windows. The goal is, of course,
to provide the includes, libraries and DLLs to be used with the more
common traditional development environments on Windows, mainly with
Microsoft Visual Studio.

The TERM environment variable must be set especially to activate the Windows
console-driver.  The driver checks if TERM is set to "#win32con" (explicit
use) or if TERM is unset or empty (implicit).

Beginning with build 17763 (Fall 2018 update), Windows 10 supports ANSI escape
sequences (Virtual Terminal support). If ncurses detects this or a later
Windows 10 version, the interpretation of the implicit TERM setting (which
means: TERM is not set or empty) changes. In this case, TERM is to be assumed
to be "ms-terminal" and ncurses acts using the regular terminfo based driver,
thus acting like a regular Terminal we all know from UNIX like environments.

This code requires WindowsNT 6.0 or better, which means on the client
Windows Vista or better, on the server Windows Server 2008 or better.

If running on Windows 10 Build 17763 or later is detected, any program
spawning a subprocess running a ncurses program should use the new
PseudoConsole support, which provides what we know as pty from the UNIX
world also for Windows. Using the CreatePseudoConsole API
(see https://docs.microsoft.com/en-us/windows/console/createpseudoconsole)
in the calling process, it is guaranteed that the called ncurses program has
a console that is required by its implementation, even if the calling program
is NOT a console program, e.g., MSYS2's own mintty Terminal emulator.

In the current MSYS2/minGW setup, building MinGW shared libraries with
libtool for ncurses seems to be broken, so I recommend NOT to use libtool.

Please note that it is also necessary to set this environment variable:

export PATH_SEPARATOR=";"

in order to parse the terminfo paths correctly. Terminfo paths should
always be separated by a semicolon, even when running under MSYS2.

All the options above are - like the whole Windows support -
experimental.

-- vile:txtmode
